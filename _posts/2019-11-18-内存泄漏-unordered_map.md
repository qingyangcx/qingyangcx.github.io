---
layout:     post
title:      使用unordered_map导致的内存泄漏
subtitle:    
date:       2019-11-18
author:     bolun
header-img: 
catalog: true
tags:
    - memory leak
---


## 前言

完成了自己第一篇博客，参考了这篇[博客](https://www.jianshu.com/p/e68fba58f75c),整个过程还是很顺利的。
<p id = "build"></p>

---

## 正文

写这篇博客源自工作中遇到的一个内存泄露的问题。内存泄露是c/c++程序员遇到的比较常见的问题了，排查起来比较麻烦。其实对内存泄露有个比较好的解决方案就是使用智能指针，在我使用智能指针后代码就没有内存泄露的问题了，当然也还有一些其他的内存问题。
下面用一个demo还原下问题。
```c++ 
class A{
public:
    A(int size=10){
        p = new char[size];
    }
    char *p;
};
int main(){
    unordered_map<int,A> map;
    map[1] = A(3);
    ...
    delete map[1].p;
    map.erase(1);
}
```
首先存在一个类A，A中的一个成员变量是char的指针，构造函数根据传入的参数size，来申请相应大小的空间，构造函数的默认值是10.main函数中将A的一个对象当做value存在一个map中，略过中间使用过程，使用完成后释放对象中的内存空间,然后从map中删除。  

看上去已经把申请的内存释放了，其实还是存在内存泄漏。原因在代码中第十行，赋值运算符左边根据key从map中取对应的value，当value不存在时会根据value的默认构造函数生成一个对象，然后和key绑定一起插入map，最后返回value的引用，这里A的默认构造函数会直接申请10bytes的内存空间。赋值运算符的右边也会调用A的构造函数生成一个对象，这里由于size==3，会申请3bytes的内存空间，最后通过编译器生成的赋值运算符将左侧对象的成员变量p更新为右侧对象的成员变量p。造成内存泄漏的原因就在于申请了两块内存空间，但是最后只释放了一块，默认构造函数申请的10bytes内存没有被释放。  

解决这个问题的话也有很多方式，比如使用map.insert({key,value})来插入，这样就只会调用一次value的构造函数，但是考虑到以后其他开发人员可能会使用map[key]=value，这样又会导致内存泄漏，因此我的修改方法是取消构造函数里的默认参数就可以了。  

---

## 后记

这个问题出现的原因可能在于之前的开发人员对map的细节了解的不够清楚，语言的一些特性一定要了解清楚后再使用，否则出了问题排查起来费时费力。

—— BY 后记于 2019.11.8


